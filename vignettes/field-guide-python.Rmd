---
title: "Field Guide to Python Issues"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
editor_options:
  chunk_output_type: inline
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

There are four foundations upon which this package rests: 

- the [Altair](https://altair-viz.github.io/) Python package, to build chart specifications
- the [reticulate](https://rstudio.github.io/reticulate/index.html) R package, to provide inter-operability with Python
- the [Vega-Lite](https://vega.github.io/vega-lite/) JavaScript framework, to render chart specifications in an HTML file.
- the [htmlwidgets](https://www.htmlwidgets.org/) R package, to provide inter-operability with HTML and JavaScript

This article deals with the first two items; the [rendering article](render.html) deals with the other two.

The purpose of this document is to try to collect in one place, in a semi-organized fashion, all the fiddly-bits we have found dealing with Python stuff. This includes:

* [**Working with Python objects**](#work-work): how to work with Altair and Vega-datasets objects
* [**Odds and ends**](#odds-ends): weird bits that don't fit anywhere else


## Working with Python objects {#work-work}

When **reticulate** returns a Python object with a custom class, it appears in R as an S3 object that *behaves* like a reference class. This means that if you see this sort of notation in Python:

```python
# Python
foo.bar()
```

You would use this notation in R:

```r
foo$bar()
```

In essence, you wherever you see a `.` in Python, use a `$` in R.

### Altair object

In Python, Altair methods return a copy of the object:

```{r}
library("altair")
library("pryr")

vega_data <- import_vega_data()

chart_old <-
  alt$Chart(
    r_to_py(vega_data$cars())
  )$encode(
    x = "Miles_per_Gallon:Q",
    y = "Horsepower:Q",
    color = "Origin:N"
  )

chart_new <- chart_old$mark_point()

address(chart_new) == address(chart_old)
```
To confirm this we note that the two charts have different memory addresses. This suggests that Altair methods return a copy of the object; it *looks* like a reference-class method, but it *acts* like an S3 method.

Let's try an assignment:

```{r}
chart_new <- chart_old

address(chart_new) == address(chart_old)
```

It seems that an assignment of an Altair object (and perhaps, by extension, Pyhton objects) returns a reference, rather than a copy. To return a copy of the object, use a copy method.

```{r}
chart_new <- chart_old$copy()

address(chart_new) == address(chart_old)
```

### Vega-datasets object

You can specify a dataset using a URL that points to a dataset, rather than a data frame. The `vega_data` object (assigned using `import_vega_data()`) contains the URLs as well as access to the data frames. 

```{r}
iris_url <- vega_data$iris$url

chart_iris <- 
  alt$Chart(iris_url)$
  encode(
    x = "sepalWidth:Q",
    y = "sepalLength:Q",
    color = "species:N"
  )$
  mark_point()

chart_iris
```

This works in your browser, but not in the RStudio IDE. This is because, for security reasons, the RStudioIDE does not let you refer external URLs that are not on their whitelist (such as YouTube and Vimeo). If you open this up in a browser, it works just fine (as long as you have access to the internet).

You can read more in the [Vega Datasets](vega-datasets.html) article.

## Odds and ends {#odds-ends}

### Dots in variables

If your encoding variables have dots in them, enclose their names in square-brackets. This has the side effect of showing the brackets in the scale labels. (TODO: find the references to this and the `\\` workaround identfied by Alicia) 

```{r iris}
chart_iris <- 
  alt$Chart(r_to_py(iris))$
  encode(
    x = "[Sepal.Width]:Q",
    y = "[Sepal.Length]:Q",
    color = "Species:N"
  )$
  mark_point()

chart_iris
```

