---
title: "Field Guide to Python Issues"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
editor_options:
  chunk_output_type: inline
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

There are four foundations upon which this package rests: 

- the [Altair](https://altair-viz.github.io/) Python package, to build chart specifications
- the [reticulate](https://rstudio.github.io/reticulate/index.html) R package, to provide inter-operability with Python
- the [Vega-Lite](https://vega.github.io/vega-lite/) JavaScript framework, to render chart specifications in an HTML file.
- the [htmlwidgets](https://www.htmlwidgets.org/) R package, to provide inter-operability with HTML and JavaScript

This article deals with the first two items; the [Field Guide to Rendering](field-guide-rendering.html) deals with the other two.

The purpose of this document is to try to collect in one place, in a semi-organized fashion, all the fiddly-bits we have found dealing with Python stuff. If you get a cryptic Python error, check here. If you find a workaround for something that isn't here, please let us know!

## Overview

A very useful way to learn how to create charts using this package is to follow the [Altair documentation](https://altair-viz.github.io). In the course of building and documenting this package, we have noted a few "gotchas" and their workarounds. If you find another, please let us know!

Here's the short version:

- Where you see a `.`, use a `$` instead.

- Altair *methods* return a copy of the object. Assignment of a Python object returns a refrence, not a copy. 

- To get the behavior you might be accustomed-to for assignment of "bare" objects, use a `$copy()` method.

- If you have a dataset that has variables with dots in their names, e.g. `Sepal.Width`, you have to make some accomodation when referring to such names in Altiar. As a workaround, you can use square-brackets to refer to "[Sepal.Width]".

- There is an Altair Chart method called `repeat()`; in R `repeat`, is a reserved word, so it needs to be enclosed in backticks: ``$`repeat`()``. 

- Where you see an inversion operator, `~`, like `~highlight`, in Altair examples, call the method explicitly from R: ``hightlight$`__invert__`()``. 

- Where you see a hyphen in the name of a Python object, use an underscore in R: `vega_data$sf_temps()`

- Where you see `["foo", "bar"]` in Altair examples, use an unnamed list in R: `list("foo", "bar")`. Where you see `{'a' = "foo", 'b' = "bar"}` in Altair examples, use a named list in R: `list(a = "foo", b = "bar")`

- Where you see a `None` in Altair examples, use a `NULL` in R.

- You may see a function argument, `baz(a = 1, **{'foo': 'bar'})` in an Altair example. In R, interpolate the dictionary into the rest of the arguments, `baz(a = 1, foo = "bar")`.

## Method chaining

When **reticulate** returns a Python object with a custom class, it appears in R as an S3 object that *behaves* like a reference class. This means that if you see this sort of notation in Python:

```python
# Python
foo.bar()
```

You would use this notation in R:

```r
foo$bar()
```

In essence, you wherever you see a `.` in Python, use a `$` in R.

```{r iris}
library("altair")

vega_data <- import_vega_data()

chart_iris <- 
  alt$Chart(r_to_py(vega_data$iris()))$
  encode(
    x = "sepalWidth:Q",
    y = "sepalLength:Q",
    color = "species:N"
  )$
  mark_point()
```

## Altair method returns copy

In Python, Altair methods return a copy of the object. To verify this, let's use `pryr::

```{r}
library("pryr")

chart_old <- chart_iris

chart_new <- chart_old$mark_point()

address(chart_new) == address(chart_old)
```

Although this *looks* like a reference-class method, the Altair method *acts* like an S3 method.

## Python assignment returns reference

The object returned by an Altair method is a modified copy of the calling-object, much as we are accustomed-to in R. However, it is important to note that using the R assignment operator (`<-`, `=`, `->`) on a Python object returns a *reference* to the object rather than a copy. 

This becomes apparent when assigning a "bare" object:

```{r}
chart_new <- chart_old

address(chart_new) == address(chart_old)
```

To return a copy of the object, use a copy method.

```{r}
chart_new <- chart_old$copy()

address(chart_new) == address(chart_old)
```

## Dots in variable names

In Python, dots can refer to a nested structure within a Data Frame variable. Vega-Lite supports such nesting, so it assumes that a dot in a variable-name will refer to a nested variable. 

This means that we can run into trouble using R's `iris` dataset:

```{r eval = FALSE}
# does not render properly

chart_iris_r <-
  alt$Chart(r_to_py(iris))$
  encode(
    x = "Sepal.Width:Q",
    y = "Sepal.Length:Q",
    color = "Species:N"
  )$
  mark_point()

chart_iris_r
```

The problem here is that there are variables whose names have dots in them, e.g. `Sepal.Width`. One workaround is to use square brackets when referring to such variable names; another is to use backslashes, `\\`:

```{r}
chart_iris_r <-
  alt$Chart(r_to_py(iris))$
  encode(
    x = "[Sepal.Width]:Q",
    y = "Sepal\\.Length:Q",
    color = "Species:N"
  )$
  mark_point()

chart_iris_r
```

As you can see, this has the side-effect of showing the brackets and slashes in the scale labels.

To fix the fix, you can set the title for each axis:

```{r}
chart_iris_r$ 
  encode(
    x = alt$X(
      field = "[Sepal.Width]", 
      type = "quantitative", 
      axis = alt$Axis(title = "Sepal.Width")
    ),
    y = alt$Y(
      field = "Sepal\\.Length", 
      type = "quantitative", 
      axis = alt$Axis(title = "Sepal.Length")
    ),
    color = "Species:N"
  )
```

## Repeat

As shown in the [View Composistion article](view-composition.html#repeat), you can use the `repeat()` method to compose one-or-more charts such that the only thing different among them is an encoding.

However, the article notes, there is a catch: `repeat` is a reserved word in R, so we have to enclose it in backticks, e.g. ``$`repeat`()``.

```{r repeat}
chart_repeat <- 
  alt$Chart(r_to_py(vega_data$iris()))$
  encode(
    x = alt$X(alt$`repeat`("column"), type = "quantitative"),
    y = alt$Y(alt$`repeat`("row"), type = "quantitative"),
    color = "species:N"
  )$
  mark_point()$
  properties(
    width = 200,
    height = 200
  )$
  `repeat`(
    row = list("petalLength", "petalWidth"),
    column = list("sepalLength", "sepalWidth")
  )

chart_repeat
```

## Inversion (`~`)

This is another case where an operator has a completely different meaning in Python than it has in R. As you know, the `~` operator is used to construct a formula. In Python, it is the [bitwise inversion operator](https://stackoverflow.com/questions/8305199/the-tilde-operator-in-python). 

You might come across this in an [Altair example](https://altair-viz.github.io/gallery/multiline_highlight.html) where the operator is used to invert a selection.

```python
# Python
highlight = alt.selection(type='single', on='mouseover',
                          fields=['symbol'], nearest=True)

alt.condition(~highlight, alt.value(1), alt.value(3))
```

There are a couple of alternatives available here, the first is to invoke the `$__invert__()` operator explicitly.

```{r eval = FALSE}
# R
highlight <-
  alt$selection(
    type = "single", 
    on = "mouseover",
    fields = list("symbol"), 
    nearest = TRUE
  )

alt$condition(highlight$`__invert__`(), alt$value(1), alt$value(3))
```

The second alternative is to swap the order of the `if_true` and `if_false` arguments in `alt$condition()`.

```{r eval = FALSE}
# R
highlight <-
  alt$selection(
    type = "single", 
    on = "mouseover",
    fields = list("symbol"), 
    nearest = TRUE
  )

alt$condition(highlight, alt$value(3), alt$value(1))
```

## Hyphens in Python Names

This comes up in Vega datasets. Let's use the `$list_datasets()` method to get the names of the datasets that contain a hyphen.

```{r datasets-hyphen}
vega_data$list_datasets() %>% stringr::str_subset("-")
```

To refer to one of these datasets in R, substitute the hyphen with an underscore:

```{r}
vega_data$sf_temps() %>% head()
```

## Lists and Dictionaries

A Python list corresponds to an atomic vector in R; a Python dictionary corresponds to a named list in R.

```python
# Python

example_list = [1, 2, 3]
example_dictionary = {'a': 1, 'b': 2, 'c': 3}
```

In practice, we find that reticulate does the right thing if we provide an R *unnamed* list where Altair expects a list, and an R *named* list where Altair expects a dictionary.

```{r}
example_list <- list(1, 2, 3)
example_dictionary <- list(a = 1, b = 2, c = 3)
```

Here's an example that uses lists and dictionaries:

```{r}

```

## None and **

These concepts are not related other that they are found in the same example:

```python
import altair as alt
import pandas as pd

activities = pd.DataFrame({'Activity': ['Sleeping', 'Eating', 'TV', 'Work', 'Exercise'],
                           'Time': [8, 2, 4, 8, 2]})

alt.Chart(activities).mark_bar().encode(
    alt.X('PercentOfTotal:Q', axis=alt.Axis(format='.0%')),
    y='Activity:N'
).transform_window(
    window=[alt.WindowFieldDef(op='sum', field='Time', **{'as': 'TotalTime'})],
    frame=[None, None]
).transform_calculate(
    PercentOfTotal="datum.Time / datum.TotalTime"
)
```

Here, we have a list containing `None`, which reticulate associates with R's `NULL`. 

We also have some syntax, `**{'as': 'TotalTime'}`. This is a mechanism to [pass additional arguments](https://softwareengineering.stackexchange.com/a/131415) to a Python function, perhaps similar to `...` in R. It is passing a dictionary, so perhaps we can add the additional named argument in R:  

```{r list-dict}
library("tibble")

activities <- 
  data_frame(
    Activity = c("Sleeping", "Eating", "TV", "Work", "Exercise"),
    Time = c(8, 2, 4, 8, 2)
  )

chart <- 
  alt$Chart(r_to_py(activities))$
  mark_bar()$
  encode(
    x = alt$X("PercentOfTotal:Q", axis = alt$Axis(format =".0%")),
    y = "Activity:N"
  )$
  transform_window(
    window = list(
      alt$WindowFieldDef(op = "sum", field = "Time", as = "TotalTime")
    ),
    frame = list(NULL, NULL)
  )$transform_calculate(
    PercentOfTotal = "datum.Time / datum.TotalTime"
  )

chart
```
